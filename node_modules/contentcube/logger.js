var Util = require("util");
var Path = require("path");
var FileSystem = require("fs");
var Step = require("step");

module.exports = function(request) {
	var instance = {};
	var options = {};
	options.targets = [target.placeholder, target.console, target.file];
	
	instance.log = function() {
		var args = Array.prototype.slice.call(arguments);
		write('log', args);
	};
	
	instance.debug = function() {
		var args = Array.prototype.slice.call(arguments);
		write('debug', args);
	};
	
	instance.error = function() {
		var args = Array.prototype.slice.call(arguments);
		write('error', args);
	};
	
	instance.warning = function() {
		var args = Array.prototype.slice.call(arguments);
		write('warning', args);
	};
	
	function write(level, messages, callback) {
		messages.forEach(function(object) {
			var message = buildMessage(level, object);
			
			Step(
				function writeToTargets() {
					var callback = this;
					options.targets.forEach(function(target) {
						target(message, callback.parallel());
					});
				},
				function allCompleted(error) {
					//callback(error);
				}
			);
		});
	}
	
	function buildMessage(level, message) {
		var date = new Date();
		var message = "["+ date.format('yyyy-mm-dd HH:MM:ss') +"]["+ level +"] " + request.client('remote-address') + ": " + Util.inspect(message, true, null);
		return message;
	}
	
	return instance;
};

var target = {
	placeholder: function(message, callback) {
		callback();
	},
	// simply forward the message to the `console.log` method.
	console: function(message, callback) {
		console.log(message);
		callback();
	},
	// stores the message in a file named after the current date.
	file: function(message, callback) {
		var date = new Date();
		var filename = date.format("yyyy-mm-dd") + '.log';
		var filepath = Path.join(application.getConfig('system.localPath'), Path.normalize('/application/logs/' + filename));
		var fileStream = FileSystem.createWriteStream(filepath, {
			'flags': 'a+',
			'encoding': 'UTF8',
			'mode': 0666
		});
		
		fileStream.on("error", function(error) {
			callback(error);
		});
		fileStream.on('drain', function() {
			callback();
		});
		
		message += "\n";
		var isBufferFull = fileStream.write(message, 'utf8');
		
		if (!isBufferFull) {
			callback();
		}
		
		fileStream.end();
	}
};