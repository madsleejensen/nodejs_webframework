var Plugin = require("contentcube/plugins/plugin");
var Util = require("util");

module.exports = function RemoteProcedureCall(application) {
	
	var mExposed = {};
	var mChannel;
	var instance = Plugin(application);
	
	// @override 
	instance.register = function() {
		mChannel = application.socketIO.of('/rpc');
		mChannel.on('connection', onConnection);
	};
	
	function onConnection(socket) {
		socket.on('request:rpc', onRemoteProcedureCallRequest);
		socket.on('request:meta_descriptions', onRequestMetaDescriptions);
		
		/**
		 * 
		 */
		function onRemoteProcedureCallRequest(request) {
			if (!mExposed[request.name] || !mExposed[request.name][request.method]) {
				socket.emit('error:rpc', {
					requestId: request.requestId,
					message: 'Unsupported method or object: ' + request.name + "." + request.method
				});
				return;
			}
		
			// push a callback as the last parameter of the request.
			// because request objects dont contain the client side callback argument.	
			var args = request.arguments;
				args.push(function onProcedureExecuted() {
					var response = {
						args: Array.prototype.slice.call(arguments),
						requestId: request.requestId
					};

					socket.emit("response:rpc", response);
				});
			
			try {
				mExposed[request.name][request.method].apply(null, args);
			}
			catch (e) {
				socket.emit('error:rpc', {
					id: requestId.requestId,
					message: 'An error occured while executing: ' + request.name + "." + request.method + '(' + request.arguments.join(", ") + ')'
				});
			}
		};
		
		/**
		 * Generate descriptions for each of the exposed objects.
		 * this meta data will be used on the client side to generate the proxy objects.
		 */
		function onRequestMetaDescriptions() {
			var metaDescriptions = {};
			
			for (var name in mExposed) {
				var object = mExposed[name];
				var description = {};

				for (var member in object) {
					if (typeof object[member] == 'function') {
						description[member] = 'method';
					}
					else {
						description[member] = 'property';
					}
				}
				
				metaDescriptions[name] = description;
			}
			
			socket.emit("response:meta_descriptions", metaDescriptions);
		}
	};
	
	/**
	 * Expose a object for RPC.
	 * @param {String} name -alias that the object can be refered to.
	 * @param {Object} instance
	 */
	instance.expose = function(name, instance) {
		if (mExposed[name]) {
			throw new Error("RPC: " + name + " has already been registered to another object.");
		}
		
		mExposed[name] = instance;
	};
	
	instance.remove = function(instance) {
		
	};
	
	instance.expose('testing', {
		hello: function(arg1, arg2, arg3, arg4, callback) {
			console.log("great");
			console.log(arguments);
			callback('fedt');
		}
	});
	
	return instance;
};