var url = require("url");
var path = require("path");
var Step = require("step");
var utils = require("contentcube/utils");

module.exports = function(application) {
	var instance = {};
	
	instance.route = function(request, callback) {
		var parts = url.parse(request.url);
		var uri = normalizeUri(parts.pathname);
		var segments = getUriSegments(uri);
		var controllerName = application.getConfig('routing.defaultControllerName');
		var actionName = application.getConfig('routing.defaultActionName');
		var moduleName = application.getConfig('routing.defaultModuleName');
		
		Step(
			function byConfiguration() { // if any routes defined in configuration, attempt to use them.
				var routeByConfiguration = matchConfigurationRoute(uri);
				var didMatchRoute = false;
				if (routeByConfiguration) {
					didMatchRoute = true;
					segments.splice(0, 2);
					controllerName = routeByConfiguration.controllerName;
					actionName = routeByConfiguration.actionName;
				}
				
				this(null, didMatchRoute);
			},
			/**
			 * Attempt to route by convention. There are two conventions depending on the value of `config.system.modulesEnabled`
			 * 		`[:module-name]/:controller-name/:action-name/:params...` if modules enabled.
			 * 		`:controller-name/:action-name/:params...` if not enabled.
			 * notice that module name is optional, if the first segment is not a valid module name, the `:controller-name/:action-name/:params...`
			 * convention is used instead.
			 */
			function byConvention(error, didRouteByConfiguration) { 
				if (error) throw error;
				if (didRouteByConfiguration) this(); // skip because routing already handled.
				var routeByConventionCallback = this;
	
				Step(
					function routeWithModule() {
						var onRouteWithModuleComplete = this;
						if (segments.length > 0 && application.getConfig('system.modulesEnabled', false)) {
							var lookupModuleName = segments[0];
							var modulePath = path.join(application.getConfig('system.localPath'), path.normalize('/application/modules/' + lookupModuleName));
							path.exists(modulePath, function(exists) {
								if (exists) {
									moduleName = segments.shift();
								}
								onRouteWithModuleComplete();
							});
						}
						else {
							onRouteWithModuleComplete();
						}
					},
					function findControllerAndAction(error) {
						if (error) throw error;
						// route controller name.
						if (segments.length > 0) { 
							controllerName = segments.shift();
						}
						// route action name.
						if (segments.length > 0) {
							actionName = segments.shift();
							// convert actions names like "hello-world-you-rock" into camelcase "helloWorldYouRock" 
						    // which action names should be formatted in.
							if (actionName.indexOf("-") != -1) {
								var nameChunks = actionName.split("-");
								var normalizedActionName = nameChunks.shift();
								nameChunks.forEach(function(chunk) {
									normalizedActionName += utils.string.ucfirst(chunk);
								});
								
								actionName = normalizedActionName;
							};
						}
						routeByConventionCallback(error);
					}
				);
			},
			function addParameters(error) {
				// left overs of `segments` are passed as parameters.
				if (segments.length > 0) { 
					request.setParams(segments);
				}
				
				request.controllerName = controllerName;
				request.actionName = actionName;
				request.moduleName = moduleName;
				
				callback(error);
			}
		);
	};
	
	/**
	 * Configuration files can specify routes that vary from the standard `:controller/:action` convention.
	 * @see config/configuration_file.js
	 * @param {String} uri
	 * @return {Object} - or null if no match.
	 */ 
	function matchConfigurationRoute(uri) {
		var routes = application.getConfig('routing.routes', []);
		var sorted = []; 
		
		for (var pattern in routes) {
			sorted.push({
				pattern: pattern,
				config: routes[pattern]
			});
		}
		// sort routes so the longest aka. the most specific route will be used.
		sorted.sort(function(a, b) {
			if (a.pattern.length > b.pattern.length) {
				return -1;
			}
			if (a.pattern.length < b.pattern.length) {
				return 1;
			}
			return 0;
		});
		
		for (var index in sorted) {
			var route = sorted[index];
			var pattern = "^" + normalizeUri(route.pattern);
			var regexp = new RegExp(pattern, 'g');
			
			if (regexp.test(uri)) {
				return route.config;
			}
		}
	}
	
	function getUriSegments(uri) {
		var segments = [];
		
		if (uri.length != 0) {
			segments = uri.indexOf("/") != -1 ? uri.split('/') : [uri];
		}
		
		return segments;
	}
	
	function normalizeUri(uri) {
		return utils.string.trimWith(uri, '/');
	}
	
	return instance;
};